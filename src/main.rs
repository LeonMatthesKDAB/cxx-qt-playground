use playground::*;
use std::ops::Deref;

struct MyObjectFFI {}

impl MyObjectFFI {
    pub fn emit(&mut self) {}
}

struct MyObject {
    // #[property]
    prop: Vec<i32>,
}

// generated by CXX-Qt
// so that we can instantiate a Qt<'a, MyObject>
impl<'a> CxxQtRustObj for &'a MyObject {
    type FFIRef = &'a MyObjectFFI;
    type FFI = MyObjectFFI;
}
impl<'a> CxxQtRustObj for &'a mut MyObject {
    type FFIRef = &'a mut MyObjectFFI;
    type FFI = &'a mut MyObjectFFI;
}

// impl Drop for Qt<'a, T> // destructs cpp

// generated by CXX-Qt
impl qt::Qt<&MyObject> {
    pub fn prop(&self) -> &Vec<i32> {
        &self.rust().prop
    }
}

impl qt::Qt<&mut MyObject> {
    pub fn set_prop(&mut self, new_value: Vec<i32>) {
        unsafe {
            self.rust_mut().prop = new_value;
        }
        unsafe { self.cpp_mut().emit() };
    }
}

impl qt::Qt<&MyObject> {
    // #[invokable]
    fn my_invokable(&self) -> i32 {
        self.prop()[0]
    }
}

impl qt::Qt<&mut MyObject> {
    fn another_invokable(&mut self) {
        self.set_prop(vec![3, 4, 5]);
    }
}

// fn invokable(rust: &MyObject, cpp: &MyObjectFFI) {
//     let mut rich_pointer = qt::Qt::new(rust, cpp);
//     rich_pointer.another_invokable();
// }

fn another_invokable(rust: &mut MyObject, cpp: &mut MyObjectFFI) {
    let mut rich_pointer = qt::Qt::new(rust, cpp);
    rich_pointer.another_invokable();
}

fn main() {}
